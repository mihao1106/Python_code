import numpy as np

# 设置随机数种子，确保每次生成的随机数相同，便于复现结果
np.random.seed(100)

# 输入数据：12个样本，每个样本有1个特征
X = np.array([1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1]).reshape(12, 1)

# 初始化隐藏层的权重和偏置
# 隐藏层权重 W2 应该与输入特征的维度相匹配（隐藏层神经元数量，输入特征数量）
W2 = np.random.randn(3, 12)  # 隐藏层有3个神经元，输入特征有12个
b2 = np.random.randn(3, 1)  # 隐藏层每个神经元的偏置

# 隐藏层的前向传播
Z2 = np.dot(W2, X) + b2
A2 = 1 / (1 + np.exp(-Z2))  # 激活函数（sigmoid）

# 为输出层设置不同的随机数种子
np.random.seed(10)

# 初始化输出层的权重和偏置
W3 = np.random.randn(2, 3)  # 输出层有2个神经元，隐藏层有3个神经元
b3 = np.random.randn(2, 1)  # 输出层每个神经元的偏置

# 输出层的前向传播
Z3 = np.dot(W3, A2) + b3
A3 = 1 / (1 + np.exp(-Z3))  # 激活函数（sigmoid）

# 计算代价函数（二元分类的均方误差）
# 这里我们假设第一个输出对应正类，第二个输出对应负类
# 目标值是 [1, 0]，分别对应两个类别
cost = 0.5 * ((1 - A3[0]) ** 2 + (0 - A3[1]) ** 2)

# 打印结果
print("隐藏层激活值：\n", A2)
print("输出层激活值：\n", A3)
print("代价：", cost)
